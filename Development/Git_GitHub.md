◆用語
・リポジトリ：ファイルやディレクトリの状態、変更履歴を記録する場所。
・リモートリポジトリ≒Github
・ブランチ：並行して複数機能を開発するためにあるもの。分岐して開発していくためのもの。自分の開発に他の人の変更の影響を受けないようにさせてくれる。コミットを指すポインタ(コミットのファイル名(=コミットの内容をハッシュ化したもの)が何かを記録しているファイル)。
・HEAD：今自分が作業しているブランチを指し示すポインタ。作業中のブランチのファイル名を記録しているファイル。


◆コマンド
・ローカルリポジトリの作成(新規PJからGitを始める方法)
cd パス(gitで管理したいファイルが格納されているディレクトリへのパス)
git init  :.gitディレクトリが作成される。このディレクトリでバージョン管理をする。
※init:initializeの略


・既存PJでGitで管理していなかった物をGitでバージョン管理する方法
cd パス(gitで管理したいファイルが格納されているディレクトリへのパス)
git init


・Gitの基本的なワークフロー
⓪ローカルリポジトリの作成
cd パス(gitで管理したいファイルが格納されているディレクトリへのパス)
git init  :.gitディレクトリが作成される。このディレクトリでバージョン管理をする。
※init:initializeの略

①ファイルの変更をステージングエリア(コミットする前の控室のようなイメージ)へ追加する
cd パス(gitで管理したいファイルが格納されているディレクトリへのパス)
git add ファイル名(e.g. first.txt)
or
git add .   :全ての変更ファイルを追加する
※ステージングエリア：複数ファイルを変更した時に、コミットするファイルを選択するためにある。
※前提として、１作業ずつ１コミットするのが原則。

②ローカルリポジトリにコミットする
git commit
→コミットメッセージを入力する画面がvim(エディタ)で開く
半角英数字でi(insert)
コミットメッセージを入力
esc
:wq
※コミット：変更にメッセージをつけてローカルリポジトリに記録すること。変更毎にコミットすることで、変更がディポジトリに時系列で記録される。コミット毎に何の変更を行ったかわかるようにすることが目的。

※わかりやすいコミットメッセージの書き方：
-目的：何をどうして変更したか第三者にわかるようにする
-書き方：
1行目 変更内容の要約
2行目 空行
3行目 変更理由


③リモートリポジトリにプッシュする
Githubでローカルリポジトリを作成する。
→GithubのWebページでリポジトリ作成
  →リポジトリネームを入力・Publicに設定
    →Create Repository
既存のリポジトリにプッシュする場合は、Githubに記載の通りにターミナル上で操作する。
(
git remote add origin https://github.com/Ken0806/intro_git.git
git branch -M master
git push -u origin master
リポジトリにアクセスするためにIDとPWを記入
完了
)


・変更をコミットして、ローカルリポジトリに変更を記録する(ファイルを変更した場合)
⓪ファイルを変更

①ファイルの変更をステージングエリアへ追加する
cd パス(gitで管理したいファイルが格納されているディレクトリへのパス)
git status   :ファイルの状況を確認(ステージングエリアに追加されていない変更は赤色で表示)
git add ファイル名(e.g. first.txt)

②ローカルリポジトリにコミットする
git status   :ステージングエリアに追加されていることを確認(ファイル名が緑色で表示)
git commit -v  :-vを記入すると、ファイルの変更箇所を確認することができる。
コミットメッセージをvimで入力
git log   :コミットのログを確認できる


・コミットできる変更内容(上記の方法との相違点を記載)
-ファイルの変更

-ファイルの新規作成

-ファイルの削除
✖︎git add ファイル名
○git rm ファイル名

-複数ファイルの変更
✖︎git add ファイル名
○git add .


・Gitリポジトリの状況確認：git commitした後からの差分を表示する(最新のcommitからの変更を表示)。
git status


・Gitの変更履歴を確認：だれがどのような変更をいつしたかを確認。リポジトリにコミットされたログを確認。
git log
git log --oneline   :１行で表示する
git log -p index.html   :ファイルの変更差分を表示する。通常のgit logだと変更のメッセージはみれるが、変更内容まではわからない。ファイル指定すれば特定のファイルの変更差分を、ファイル指定しなければ全てのファイルの変更差分を表示。
git log -n 3(表示したい変更数)      :表示したい変更数を指定して表示


・ファイルの変更差分を確認
①ローカル(ワークツリー)とステージとの差分を確認する場合
git diff

②ステージとコミットの差分を確認する場合
git diff HEAD


・Githubにプッシュ
①ローカルリポジトリにリモートリポジトリを登録(プッシュ先を登録するイメージ？)
git remote add origin https://github.com/user/initial.git(ディレクトリ名)    :originという名前がurl(リモートリポジトリ)を示すように登録している。いわゆるエイリアス。

②ローカルリポジトリの内容をリモートリポジトリにプッシュ
git push origin master   :originというリモートリポジトリへmasterというブランチを送信することを意味。MASTERはデフォルトのブランチ名。今のバージョンのGithubだと、デフォルトのブランチ名がmasterでなくmainかも。


・管理しないファイルをGitの管理から外す方法:.ignoreファイルに指定することで、ファイルをGitの管理から外すことができる。自動生成されるファイルやパスワードが記載されているファイルが主な例。


・コミットしてしまったファイルを管理から外す方法：
git rm コミットしたファイル名     :ローカルのファイルごと削除される。
※ファイルを削除するだけでは、ファイル管理から外すことはできない。
or
git rm -r ディレクトリ名    :ディレクトリ毎削除したい場合。ローカルのファイル毎削除される。

git rm --cached ファイル名   :ローカルのファイルは残した状態で、gitの管理を外す。


・他の人がすでに作成しているプロジェクトから始める場合
⓪ローカルに新規フォルダを作成する

①Gitリポジトリのコピーを作成する
git clone<リポジトリ名>       :これによりローカルリポジトリ(GitHub)に保存されたファイルと.gitリポジトリの両方がローカルのワークツリー(フォルダ)に追加される。
git clone https://github.com/atom/atom.git      :このURLはコピーしたいプロジェクトのGitHubのページから取得する


・変更をステージに追加する
git add ファイル名
git add ディレクトリ名
git add .     :ワークツリー(作業しているローカルのディレクトリのこと)のすべてのファイル、ディレクトリを追加する


・ステージにあげた変更を.gitディレクトリ(ローカルリポジトリ)に記録する(コミット)
git commit
git commit -v   :ファイルの変更内容も見ることができる
git commit -m "メッセージ"   :エディタを立ちあげずにコミット可能
※わかりやすいコミットメッセージの書き方：
-目的：何をどうして変更したか第三者にわかるようにする
-書き方：
1行目 変更内容の要約
2行目 空行
3行目 変更理由


・現在の変更状況の確認：コミットやステージに追加する前に、以下の手順にしたがってどのファイルが変更されたかを確認すること(編集途中のファイルをコミットしないようにするため)。
git status    :変更されたファイル(ワークツリーとステージでの差異・ステージとリポジトリでの差異)を確認できる
-ワークツリーとステージでの差異:前回ステージに追加(add)してからワークツリー上で変更されたファイル
-ステージとリポジトリでの差異：前回コミットしてからステージに追加(add)されたファイル


・変更差分の確認:add(ステージに追加)やcommit(リポジトリに追加)するまえに、以下の手順で差分を確認する癖をつける。
-git addする前の変更分:ワークツリーとステージの間の差分。差分がなければ何も表示されない。
git diff
git diff ファイル名

-git addした後の変更分：ステージと(ローカル)リポジトリの間の差分。差分がなければ何も表示されない。
git diff --staged


・変更履歴の確認:
git log
git log --oneline    :1行で表示する
git log -p ファイル名  :ファイルを指定して履歴を確認する
git log -n コミット数  :表示するコミット数を制限する


・ファイルの削除を記録する
-ファイルが不要になった場合：commit記録からも削除し、ワークツリーからも削除する
git rem ファイル名
git rem -r ディレクトリ名

-ファイルは必要だが、gitには載せたくないファイルが有る場合：ワークツリーにはファイルを残し、gitの記録からのみファイルを削除する
git rm --cached ファイル名


・ファイルの移動を記録する
git mv 旧ファイル名 新ファイル名

以下の3処理と同じ意味
mv 旧ファイル名 新ファイル名      ワークツリーのファイル名を変更
git rm 旧ファイル名
git add 新ファイル名


・プッシュする：リモートリポジトリにローカルの内容をアップすること
①リモートリポジトリを新規追加する
git remote add origin GitHubのURL     originというショートカット(名前)でGitHubのリモートリポジトリを登録するという意味。これにより、今後はoriginという名前でGitHubリポジトリにアップしたり取得したりすることができる様になる。逆にこれをしないと、毎回URLでアップしたり取得したりしなくてはいけない。

②コミットした内容を、リモートリポジトリに送信する
git push リモート名 ブランチ名
git push origin master      :masterはデフォルトのブランチ名
git push -u origin master   :初回にプッシュするときのみ -u のオプションを付けておくことで、次回以降プッシュするときは"git push"だけでよくなる。


・コマンドにエイリアスをつける：毎回正式名を入力するのは手間なため
git config --global alias.エイリアス名 正式名
(git config は設定の変更をするコマンド --globalオプションはPC全体へ、という意味)
git config --global alias.ci commit
git config --global alias.st status
git config --global alias.br branch
git config --global alias.co checkout


・バージョン管理しないファイルをGitの管理から外す方法:無視するファイルは①パスワードなどの機密情報を載せたファイル②チーム開発で不要なファイル(キャッシュ等)
→
.gitignoreファイルに指定する。
-.gitignoreファイルの書き方
＃＃から始まる行はコメント

# 指定したファイルを除外するには、ファイル名を直接記入する
ファイル名
index.html

# ルートディレクトリを指定する:そのPJの一番上部のディレクトリ
/root.html

# ディレクトリ以下を除外
dir/

# /以外の文字列にマッチ : *
/*/*.css


・変更をもとに戻す
-ワークツリーのファイルへの変更をもとに戻す方法:前回のgit addされた情報に戻される
git checkout -- ファイル名
git checkout -- ディレクトリ名
git checkout -- .       すべてのファイルの変更を取り消す

-ステージに追加した変更をもとに戻す方法:ワークツリーでファイル変更し、git addした内容をもとに戻す
git reset HEAD ファイル名
git reset HEAD ディレクトリ名
git reset HEAD .      :全変更を取り消す
※変更をステージから取り消すだけなので、ワークツリー上のファイルには影響を与えない点に注意。
ファイルももとに戻したいときはgit reset 後に git checkout を使用すればOK

-直前のコミットをもとに戻す方法：
git commit --amend     :今のステージの状況をもとに、直前のコミットをやり直すという処理。
※リモートリポジトリにプッシュしたコミットはやり直してはいけない。


・GitHub(リモートリポジトリ)とのやり取り
-リモートリポジトリの情報を確認する
git remote    :設定しているリモートリポジトリの情報を取得
git remote -v    :対応するURLを表示する


-リモートリポジトリを追加する:リモートリポジトリは複数登録できる。
git remote add リモート名 リモートURL


-リモートリポジトリの詳細な状況を確認する
git remote show リモート名
git remote show origin


-リモートリポジトリからファイルを取得する：取得する方法は２種類ある(フェッチとプル)
①フェッチ：★★★★★基本的にはこちらを使う！！
git fetch リモート名
git fetch origin    この場合は remotes/bak/master  remotes/origin/master  にデータが格納される。
※フェッチでは、ローカルリポジトリにデータを落としてくるだけであり、ワークツリーにはデータは格納されない。
※保存先は remotes/リモート/ブランチ(https://qiita.com/wann/items/688bc17460a457104d7d)

リモートの情報をワークツリーに反映するには上の処理の後に以下のコマンドを実施
git merge リモートリポジトリ名 ブランチ名
git merge origin master


②プル：リモートから情報を取得して、マージまでを１つのコマンドで実施したい時に使用。基本的には使わない。
git pull リモートリポジトリ名 ブランチ名
git pull origin master
git pull  は上のコマンドと同意

また、以下のコマンドを実施するのと同じことをしている。
git fetch origin master
git merge origin/master
※リモートブランチはリモートリポジトリ名/ブランチ名(origin/master, origin/feature)といった名称でローカルリポジトリに保存される


-リモート名を変更・削除する
git remote rename 旧リモート名 新リモート名
git remote rename tutorial new_tutorial

git remote rm リモート名
git remote rm new_tutorial



・新しいブランチの作成
git branch ブランチ名
git branch feature
※この段階ではブランチを作成するだけで、ブランチの切り替え(HEADの変更)までは行わない点に注意
※以下のコマンドで、ブランチの作成と切り替えを同時に行える。
git checkout -b 新ブランチ名    :ブランチの作成と切り替えを同時に行いたい場合はこちらを使用。

・ブランチの一覧を表示
 git branch
 git branch -a    :すべてのブランチを表示する＝リモートリポジトリも表示される


・ブランチの切り替え
git checkout 既存のブランチ名
git checkout feature

git checkout -b 新ブランチ名    :ブランチの作成と切り替えを同時に行いたい場合はこちらを使用。


・変更をマージする：マージ＝他の人の変更内容を自分のブランチに反映すること。
git merge ブランチ名
git merge リモートリポジトリ名/ブランチ名
git merge origin/master    originというリモート(github)リポジトリのmasterブランチの内容を、自分が作業中(HEAD)のブランチにマージするという意味。自分が作業中のブランチをベースにして、masterブランチの変更を取り込む。


・コンフリクトを解決する：コンフリクト＝複数人が同じファイルの同じ行に対して異なる変更したことにより、どの変更を優先したらよいかわからなくなる状態
-コンフリクト時の表示例
<h1>git tutorial</h1>
<h1>ようこそ</h1>
<<<<<<<< HEAD
<p>git addについて学ぼう</p>
========
<p>git commitについて学ぼう</p>
>>>>>>>> feature

-解決後:ファイルの内容を書き換えれば良い
<h1>git tutorial</h1>
<h1>ようこそ</h1>
<p>git addについて学ぼう</p>
<p>git commitについて学ぼう</p>


-コンフリクトの解消方法
①マージの実施
git merge ブランチ名
→以下の様な、マージができないことを示すメッセージが出力される
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.

②コンフリクトしたファイルの調査
git status
→以下の出力で、コンフリクトしているファイルを確認。
On branch master
You have unmerged paths.
  (fix conflicts and run "git commit")
  (use "git merge --abort" to abort the merge)

Unmerged paths:
  (use "git add <file>..." to mark resolution)
	both modified:   index.html

③対象ファイルを開き、コンフリクト箇所の修正：下のように、コンフリクト箇所に対して修正がかかっているので、正しい変更内容を残すように修正する。
<h1>git tutorial</h1>
<h1>ようこそ</h1>
<<<<<<<< HEAD
<p>git addについて学ぼう</p>
========
<p>git commitについて学ぼう</p>
>>>>>>>> feature

④修正したファイルをadd,commitする。



・ブランチ名を変更・削除
git branch -m 変更後のブランチ名     :そのとき自分が作業しているブランチの名前を変更する
git branch -m new_branch

git branch -d 削除したいブランチ名    ：masterにマージされていない変更が残っている場合は削除されない
git branch -D 削除したいブランチ名    ：強制削除する



・ブランチを利用した開発の流れ：masterブランチをリリース用のブランチに、開発はトピックブランチを作成してすすめるのが基本。
→masterは開発時は使わず、リリース専用のブランチとする。
これにより、masterをリリースしている内容で保つことができる。
＝リリースしている実装内容がひと目で分かる
＆リリースしているアプリでバグが発生した場合は、１つ前のバージョンに戻すことで、一時的にバグを解消できる。

各トピックで開発が完了し次第maseterにマージする。
常に最新のmasterに対してマージすること。
また、ブランチを切る(=新しく違うトピックようのブランチを作成する)ときは、
最新のmasterからブランチを切ること。



・GitHubを利用した開発手順
-プルリクエスト:自分の変更したコードをリポジトリに取り込んでもらえるように依頼する機能。レビューをする/してもらうためにある機能。
①ローカルでmasterブランチを最新の状態に更新
git pull origin masterなど
git status で差分を確認
②ローカルでブランチを作成
git checkout -b ブランチ名(今回はpull_requestという名前とする)
③ローカルでファイルを変更→コミットまで実施
④GitHubにプッシュ
git push origim pull_request
⑤プルリクエストを送る
GitHubをブラウザで開き、"Pull requests"タブを開く
→New pullrequestボタンを押下
→base:    compare:     を設定する(compareがプルリクするブランチ,baseはもともとの基盤となるブランチを選ぶ)
 →create pullrequestボタンを押下
 →プルリクのタイトルと本文を記入
 →create pullrequestボタンを押下
⑥コードレビューを依頼&実施
pullrequestのページのrebiviewの箇所でレビュアーを選択
→設定されたレビュアーにレビュー依頼のメールが送られる
 →レビュアー：メール確認後、レビューするpullrequestのページを開き、file changedのページを開く
 →差分を確認。修正箇所があれば、該当行にカーソルを近づけるとコメントが追記できるようになるので、そちらに修正内容を記載する。
 →レビュイーに修正内容を通知が行くはずなので、修正を反映する
 →上記の内容を修正箇所がなくなるまで繰り返す
 →修正箇所がなくなったら、レビュアーはレビューのページで"Finish your review"ボタンを押す
 →approveボタンを選択して、送信する＝レビュー終わり
⑦プルリクエストをリモートリポジトリのmaster等にマージ
プルリクエストのページで"merge pullrequest"を押下"confirm merge"を押下
⑧ブランチを削除
 ⑦のページで"delete branch"を選択
⑨上記の内容をローカルにも反映する
git checkout master
git pull origin master
git branch -d pull_request



・GitHub Flowを利用した開発手順：GitHub Flow=GitHubを利用した開発手法の１つ。GitHub社が用いているワークフロー。
-GitHub Flowの流れ
①ローカル：masterブランチからブランチを作成
②ローカル：①のブランチでファイルを変更し、コミット
③ローカル：①のブランチをGitHubへプッシュ
④リモート：プルリクを送る
⑤リモート：コードレビューし、masterブランチにマージ
⑥リモート：masterブランチをデプロイ=本番サーバーにリリースする
⑦ローカル：masterをプルし、マージ完了したブランチを削除

-実践のポイント
masterブランチは常にデプロイできる状況に保つ
新開発はmasterブランチから新しいブランチを作成してスタートすること
定期的にプッシュすること(他のチームメンバーが開発状況を確認することができるため)
必ずプルリクすること(レビューなしの状態でリリースされないようにする)
masterブランチにマージしたらすぐにデプロイする
  →そのためにテストとデプロイを自動化するべき



・リベースで変更履歴を修正する:リベース＝変更を統合する際に、履歴をきれいに整えるために使う機能。
上記ではマージを使って変更を取り込んでいたが、他の手段の１つとしてリベースがある。
-手順
masterブランチとfeatureブランチがあったとする。
git checkout feature      featureブランチに切り替え
git rebase ブランチ名       親コミットを左で指定したブランチに変更する という意味
git checkout master        masterブランチに切り替え
git merge feature          featureブランチの内容をマージ

→メリット：親コミットをmasterなどに変更した上でマージすることで、履歴を分岐させずに一直線にすることができる。


-リベースでしてはいけないこと:GitHubにプッシュしたコミットをリベースすること。

-リベースとマージの使い分け方：Gitの運用方針次第
マージ：作業の履歴を残したい場合はこちらを使う
 メリット：コンフリクトの解決が比較的簡単
 デメリット：マージコミットがたくさんあると、履歴が複雑化する
リベース：作業の履歴を残すことよりも、履歴をきれいに保つことを優先する場合はこちらを使う
 メリット：履歴をきれいに保つ事ができる
 デメリット：コンフリクトの解決が若干面倒(コミットそれぞれに解消が必要)

-プルの設定をリベースに変更する方法:プルにはマージ型とリベース型の２種類がある。
マージ型：マージコミットが残るので、マージの記録を残したい場合に使う
git pull リモート名 ブランチ名
git pull origin master

リベース型：マージコミットが残らないので、GitHubの内容を取得したいだけのときはこちらを使う
※参照：https://qiita.com/masatomix/items/4bdb5f25de632c97f37f
git pull --rebase リモート名 ブランチ名
git pull --rebase origin master
=
git fetch hoge
git rebase hoge

リベース型への設定方法：
git config --global pull.rebase true

masterブランチでgit pullするときのみリベース型にする方法
git config branch.master.rebase true


-リベースで履歴を書き換える方法:あまり理解ができていないので、必要に応じて以下の動画をみて理解する
https://www.udemy.com/course/unscared_git/learn/lecture/7091520#notes



・タグ付けをする：タグ＝コミットを参照しやすくするためにつける名前。リリースポイントにタグを付けることが多い。
-タグの一覧を表示する:アルファベット順にすべてのタグを表示する
git tag


-パターンを指定してタグを表示する方法
git tag -l "タグに含まれる文字列"
git tag -l "201705"
→20170504_1
→20170504_2
→20170505_1


-タグを作成する
1)注釈付き版(annotated)のタグ:基本的にこちらを使う, タグ名だけでなく、コメントや署名(誰がタグを付けたか)もつけられる。
直近のコミットに対するタグ付け
git tag -a タグ名 -m "メッセージ"
git tag -a 20170502_01 -m "version 20170502_01"
※-a:annotated 注釈付きタグを作成するという意味
 -m  エディタを立ち上げずにメッセージを入力できる


2)軽量版(lightweight)のタグ:タグの名前のみをつけることができる
直近のコミットに対するタグ付け
git tag タグ名
git tag 20170502_01

過去のコミットにつける場合
git tag タグ名 コミット名
git tag 20170502_01 8a6cbc4


-タグのデータを表示する:タグのデータと関連付けられたコミットを表示する(タグ付けした人の情報、タグ付けした日時、注釈メッセージ、コミット)
git show タグ名
git show 20170502_01


-タグをリモートリポジトリに送信する:git push コマンドで別途指定する(git push だけでは送信されていない)
タグ指定する場合
git push リモートリポジトリ名 タグ名
git push origin 20170502_01

タグを一斉に送信する場合
git push リモートリポジトリ名 --tags
git push origin --tags



・作業を一時避難する方法：コミットはしないけど、一次避難する(ブランチ移動する際にはコミットが必要になるため、一次避難させる必要がある)
-状況
作業が途中なのでコミットしたくないけれど、別のブランチで作業をしないといけない場合。

-一次避難(スタッシュ)方法:以下のコマンドにより、ワークツリーやステージの情報をスタッシュに保存できる。また、スタッシュに保存されたファイルは、変更前の状態(直前のコミットの状態)になる。
git stash
or
git stash save      上と同じ意味


-避難させた作業を確認する方法
git stash list


-避難させた作業を復元する
最新の作業を復元する(ワークツリーは復元されるがステージの状況は復元されない)
git stash apply
ワークツリーだけでなくステージの状況も復元する
git stash apply --index

特定の作業を復元する
git stash apply スタッシュ名      スタッシュ名はgit stash listで確認する
git stash apply stash@{1}


-避難した作業を削除する
最新の作業を削除
git stash drop

特定の作業を削除
git stash drop スタッシュ名
git stash drop stash@{1}

全作業を削除する
git stash clear
